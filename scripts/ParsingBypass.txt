uses SysUtils, Classes, RegExpr;  // подключили модули
var
Buff:TL2Buff;
Npc: TL2Npc;

function Bypass(dlg: string): boolean;
var
  RegExp: TRegExpr;
  SL: TStringList;
  i: integer;
  bps: string;
begin
  Result:= true;                                            // задаем результат по умолчанию
  RegExp:= TRegExpr.Create;                                 // инициализируем объекты для дальнейшей работы
  SL:= TStringList.Create;
  
  RegExp.Expression:= '(<a *(.+?)</a>)|(<button *(.+?)>)';  // задаем регэксп на поиск всех возможных bypass'ов 
  if RegExp.Exec(Engine.DlgText) then                       // если нашлелся нужный шаблон, то
    repeat SL.Add(RegExp.Match[0]);                         // заполняем наш список такими совпадениями
    until (not RegExp.ExecNext);                            // пока не закончатся шаблоны

  for i:= 0 to SL.Count-1 do begin                          // теперь пробегаемся по нашему списку
    if (Pos(dlg, SL[ i ]) > 0) then begin                     // если в i-ой строке нашелся искомый текст, то
      RegExp.Expression:= '"bypass -h *(.+?)"';             // ищем шаблон текста c bypass'ом
      if RegExp.Exec(SL[ i ]) then                            // и если нашли, то копирем из него интересующий нас кусок
        bps:= TrimLeft(Copy(RegExp.Match[0], 12, Length(RegExp.Match[0])-12));
    end;
  end;
  
  Print(bps);                                               // распечатываем конечный вариант bypass'а
  if (Length(bps) > 0) then Engine.BypassToServer(bps);     // если его длина > 0, то отправляем на сервер
  
  RegExp.Free;                                              // не забываем освобождать память
  SL.Free;
end;
